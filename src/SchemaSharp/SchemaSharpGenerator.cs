using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using NJsonSchema;
using NJsonSchema.CodeGeneration.CSharp;
using System.Text;

namespace SchemaSharp;

/// <summary>
/// A source generator that creates .NET types from JSON schema definitions.
/// </summary>
[Generator]
public sealed class SchemaSharpGenerator : IIncrementalGenerator
{
    private const string AttributeName = "GenerateFromJsonSchemaAttribute";
    private const string Namespace = "SchemaSharp";

    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(RegisterMarkerAttribute);

        var typeInformationResultsProvider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                $"{Namespace}.{AttributeName}",
                predicate: IsSyntaxTargetForGeneration,
                transform: GetTypeNameToGenerate);

        ReportDiagnostics(context, typeInformationResultsProvider);

        var typeInformationCollectionProvider = typeInformationResultsProvider
            .Where(static x => x.Value is not null)
            .Select(static (x, _) => x.Value!)
            .Collect()
            .Select(static (results, token) => results.ToEquatableArray(token));

        var schemaResultsProvider = context.AdditionalTextsProvider
            .Where(static text => text.Path.EndsWith("schema.json", StringComparison.InvariantCultureIgnoreCase))
            .Select(GetJsonSchema);

        ReportDiagnostics(context, schemaResultsProvider);

        var schemaCollectionProvider = schemaResultsProvider
            .Where(static x => x.Value is not null)
            .Select(static (x, _) => x.Value!)
            .Collect()
            .Select(static (x, t) => x.ToEquatableArray(t));

        var templatePathProvider = context.AdditionalTextsProvider
            .Where(static text => text.Path.EndsWith(".liquid"))
            .Select(static (x, _) => Path.GetDirectoryName(x.Path))
            .Collect()
            .Select(static (x, _) => string.Join(";", x));

        var typeGeneratorConfigurationResultsProvider = schemaCollectionProvider
            .Combine(typeInformationCollectionProvider)
            .Select((combined, token) => GetTypeGeneratorConfigurationResults(combined.Left, combined.Right, token))
            .SelectMany((x, _) => x);

        ReportDiagnostics(context, typeGeneratorConfigurationResultsProvider);

        var typeGeneratorConfigurationProvider = typeGeneratorConfigurationResultsProvider
            .Where(static x => x.Value is not null)
            .Select(static (x, _) => x.Value!)
            .Collect()
            .Select(static (x, _) => x.ToEquatableArray())
            .Combine(templatePathProvider);

        context.RegisterSourceOutput(typeGeneratorConfigurationProvider, GenerateType);
    }

    private static void ReportDiagnostics<T>(IncrementalGeneratorInitializationContext context, IncrementalValuesProvider<Result<T?>> provider)
        where T : IEquatable<T?>
    {
        context.RegisterSourceOutput(
            provider.SelectMany(static (result, _) => result.DiagnosticInfos),
            static (x, diagnosticInfo) => x.ReportDiagnostic(diagnosticInfo.ToDiagnostic()));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node, CancellationToken token)
    {
        token.ThrowIfCancellationRequested();

        return node switch
        {
            ClassDeclarationSyntax => true,
            _ => false,
        };
    }

    private static void RegisterMarkerAttribute(IncrementalGeneratorPostInitializationContext context)
    {
        context.AddEmbeddedAttributeDefinition();
        context.AddSource("GenerateJsonSchemaAttribute.g.cs", SourceText.From($$"""
// <auto-generated/>
using System;
using Microsoft.CodeAnalysis;

namespace {{Namespace}}
{
    /// <summary>
    /// Marks a type as being generated from a JSON schema.
    /// </summary>
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [global::Microsoft.CodeAnalysis.EmbeddedAttribute]
    [global::System.AttributeUsage(global::System.AttributeTargets.Class | global::System.AttributeTargets.Struct, Inherited = false, AllowMultiple = false)]
    [global::System.Runtime.CompilerServices.CompilerGenerated]
    internal sealed class {{AttributeName}} : Attribute {}
}
""", Encoding.UTF8));
    }

    private static Result<TypeSymbolInformation?> GetTypeNameToGenerate(GeneratorAttributeSyntaxContext context, CancellationToken token)
    {
        token.ThrowIfCancellationRequested();

        // The null forgiving operator can be used because we are only dealing with type declaration syntax nodes at this point.
        // If we would end up here with other types of syntax nodes, the predicate at the call site has an issue.
        var typeSymbol = context.SemanticModel.GetDeclaredSymbol(context.TargetNode, token)!;

        TypeSymbolInformation typeSymbolInformation = new(typeSymbol.Name, typeSymbol.ContainingNamespace.ToString());

        return new(typeSymbolInformation, new());
    }

    private static Result<JsonSchemaInformation?> GetJsonSchema(AdditionalText additionalText, CancellationToken token)
    {
        token.ThrowIfCancellationRequested();

        var json = additionalText.GetText(token)?.ToString();

        if (json == null)
        {
            var descriptor = new DiagnosticDescriptor(
                    "SCHEMASHARP0002"
                    , $"Could not read JSON schema from {additionalText.Path}"
                    , "The JSON schema file could not be read."
                    , $"{nameof(SchemaSharp)}.Generators"
                    , DiagnosticSeverity.Error
                    , true);

            var diagnosticInfo = new DiagnosticInfo(descriptor, Location.None);

            return new(null, new([diagnosticInfo]));
        }

        var jsonSchema = JsonSchema.FromJsonAsync(json, token).ConfigureAwait(false).GetAwaiter().GetResult();
        var jsonSchemaInformation = new JsonSchemaInformation(jsonSchema, additionalText.Path);

        return new(jsonSchemaInformation, new());
    }

    private static EquatableArray<Result<TypeGeneratorConfiguration?>> GetTypeGeneratorConfigurationResults(
        EquatableArray<JsonSchemaInformation> jsonSchemas,
        EquatableArray<TypeSymbolInformation> typeSymbols,
        CancellationToken token)
    {
        token.ThrowIfCancellationRequested();

        var result = typeSymbols.Select(x => GetTypeGeneratorConfigurationResult(x, jsonSchemas, token)).ToEquatableArray();

        return result;
    }

    private static Result<TypeGeneratorConfiguration?> GetTypeGeneratorConfigurationResult(
        TypeSymbolInformation typeSymbolInformation,
        EquatableArray<JsonSchemaInformation> jsonSchemaInfos,
        CancellationToken token)
    {
        token.ThrowIfCancellationRequested();

        var schemaMatches = jsonSchemaInfos.Where(x => x.JsonSchema.Title == typeSymbolInformation.Name).ToArray();

        if (schemaMatches.Length != 1)
        {
            var descriptor = new DiagnosticDescriptor(
                    "SCHEMASHARP0003"
                    , $"An unambiguous schema assignment for {typeSymbolInformation.Name} could not be found."
                    , "The type name and JSON schema title must match and be unique."
                    , $"{nameof(SchemaSharp)}.Generators"
                    , DiagnosticSeverity.Error
                    , true);
            var diagnosticInfo = new DiagnosticInfo(descriptor, Location.None);

            return new(null, new([diagnosticInfo]));
        }

        var configuration = new TypeGeneratorConfiguration(typeSymbolInformation, schemaMatches.Single().JsonSchema);

        return new(configuration, new());
    }

    private static void GenerateType(SourceProductionContext context, (EquatableArray<TypeGeneratorConfiguration> Configurations, string TemplateDirectories) input)
    {
        foreach (var configuration in input.Configurations)
        {
            var settings = new CSharpGeneratorSettings
            {
                Namespace = configuration.TypeSymbolInformation.Namespace,
                ClassStyle = CSharpClassStyle.Poco,
                GenerateDefaultValues = false,
                GenerateOptionalPropertiesAsNullable = true,
                GenerateNullableReferenceTypes = true,
                TemplateDirectory = input.TemplateDirectories,
            };

            var generator = new CSharpGenerator(configuration.JsonSchema, settings);
            var code = generator.GenerateFile(configuration.TypeSymbolInformation.Name);

            context.AddSource($"{configuration.TypeSymbolInformation.Name}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }
}